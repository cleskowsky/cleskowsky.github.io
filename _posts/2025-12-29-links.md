---
layout: post
title: "Weekly notes: Thoughtful piece about having impact over a career and how much of it isn't about code, or being clever"
---

* [IPv4 route lookup on Linux](https://vincent.bernat.ch/en/blog/2017-ipv4-route-lookup-linux): Neat description of how
  ip routing lookups work in the linux kernel
* [Quoting Liz-Fong Jones](https://simonwillison.net/2025/Dec/30/liz-fong-jones/#atom-everything): A bluesky
  conversation where Liz talks about being a context manager for llms

> In essence a language model changes you from a programmer who writes lines of code, to a programmer that manages the
> context the model has access to, prunes irrelevant things, adds useful material to context, and writes detailed
> specifications. If that doesn't sound fun to you, you won't enjoy it.
>
> Think about it as if it is a junior developer that has read every textbook in the world but has 0 practical experience
> with your specific codebase, and is prone to forgetting anything but the most recent hour of things you've told it.
> What do you want to tell that intern to help them progress?
>
> Eg you might put sticky notes on their desk to remind them of where your style guide lives, what the API documentation
> is for the APIs you use, some checklists of what is done and what is left to do, etc.
>
> But the intern gets confused easily if it keeps accumulating sticky notes and there are now 100 sticky notes, so you
> have to periodically clear out irrelevant stickies and replace them with new stickies.

* [What Does a Database for SSDs Look Like?](https://brooker.co.za/blog/2025/12/15/database-for-ssd): Marc Brooker never
  disappoints!

> If we had to throw these databases away and begin from scratch in 2025, what would change and what would remain?
>
> I’d keep the relational model, atomicity, isolation (but would probably pick SNAPSHOT as a default), strong
> consistency, SQL, interactive transactions, and the other core design decisions of relational databases. But I’d move
> durability, read and write scale, and high availability into being distributed rather than single system concerns. I
> think that helps with performance and cost, while making these properties easier to achieve. I’d mostly toss out local
> durability and recovery, and all the huge history of optimizations and data structures around that3, in favor of getting
> better properties in the distributed setting. I’d pay more attention to internal strong isolation (in the security
> sense) between clients and workloads. I’d size caches for a working set of between 30 seconds and 5 minutes of accesses.
> I’d optimize for read transfers around that 32kB sweet spot from local SSD, and the around 8kB sweet spot for networks.
>
> Probably more stuff too, but this is long enough as-is.

## 21 Lessons From 14 Years at Google

This was a delightful piece overall. I've pulled out a few things that really resonated ...

> 3. Bias towards action. Ship. You can edit a bad page, but you can’t edit a blank one.
>
> The quest for perfection is paralyzing. I’ve watched engineers spend weeks debating the ideal architecture for something they’ve never built. The perfect solution rarely emerges from thought alone - it emerges from contact with reality. AI can in many ways help here.
>
> First do it, then do it right, then do it better. Get the ugly prototype in front of users. Write the messy first draft of the design doc. Ship the MVP that embarrasses you slightly. You’ll learn more from one week of real feedback than a month of theoretical debate.
>
> Momentum creates clarity. Analysis paralysis creates nothing.

> 5. Novelty is a loan you repay in outages, hiring, and cognitive overhead.
>
> Treat your technology choices like an organization with a small “innovation token” budget. Spend one each time you adopt something materially non-standard. You can’t afford many.
> 
> The punchline isn’t “never innovate.” It’s “innovate only where you’re uniquely paid to innovate.” Everything else should default to boring, because boring has known failure modes.
> 
> The “best tool for the job” is often the “least-worst tool across many jobs”-because operating a zoo becomes the real tax.

> 11. Abstractions don’t remove complexity. They move it to the day you’re on call.
>
> Every abstraction is a bet that you won’t need to understand what’s underneath. Sometimes you win that bet. But something always leaks, and when it does, you need to know what you’re standing on.
> 
> Senior engineers keep learning “lower level” things even as stacks get higher. Not out of nostalgia, but out of respect for the moment when the abstraction fails and you’re alone with the system at 3am. Use your stack.
> 
> But keep a working model of its underlying failure modes.

Other chestnuts:

* Writing is really important
* Winning debates may be followed up with quiet resistance
* Avoid the clever
* Experience compounds

[Source](https://addyosmani.com/blog/21-lessons/)
