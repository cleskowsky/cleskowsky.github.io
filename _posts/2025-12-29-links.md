---
layout: post
title: "Weekly notes"
---

* [IPv4 route lookup on Linux](https://vincent.bernat.ch/en/blog/2017-ipv4-route-lookup-linux): Neat description of how
  ip routing lookups work in the linux kernel
* [Quoting Liz-Fong Jones](https://simonwillison.net/2025/Dec/30/liz-fong-jones/#atom-everything): A bluesky
  conversation where Liz talks about being a context manager for llms

> In essence a language model changes you from a programmer who writes lines of code, to a programmer that manages the
> context the model has access to, prunes irrelevant things, adds useful material to context, and writes detailed
> specifications. If that doesn't sound fun to you, you won't enjoy it.
>
> Think about it as if it is a junior developer that has read every textbook in the world but has 0 practical experience
> with your specific codebase, and is prone to forgetting anything but the most recent hour of things you've told it.
> What do you want to tell that intern to help them progress?
>
> Eg you might put sticky notes on their desk to remind them of where your style guide lives, what the API documentation
> is for the APIs you use, some checklists of what is done and what is left to do, etc.
>
> But the intern gets confused easily if it keeps accumulating sticky notes and there are now 100 sticky notes, so you
> have to periodically clear out irrelevant stickies and replace them with new stickies.

* [What Does a Database for SSDs Look Like?](https://brooker.co.za/blog/2025/12/15/database-for-ssd): Marc Brooker never
  disappoints!

> If we had to throw these databases away and begin from scratch in 2025, what would change and what would remain?
>
> I’d keep the relational model, atomicity, isolation (but would probably pick SNAPSHOT as a default), strong
> consistency, SQL, interactive transactions, and the other core design decisions of relational databases. But I’d move
> durability, read and write scale, and high availability into being distributed rather than single system concerns. I
> think that helps with performance and cost, while making these properties easier to achieve. I’d mostly toss out local
> durability and recovery, and all the huge history of optimizations and data structures around that3, in favor of getting
> better properties in the distributed setting. I’d pay more attention to internal strong isolation (in the security
> sense) between clients and workloads. I’d size caches for a working set of between 30 seconds and 5 minutes of accesses.
> I’d optimize for read transfers around that 32kB sweet spot from local SSD, and the around 8kB sweet spot for networks.
>
> Probably more stuff too, but this is long enough as-is.